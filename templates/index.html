<!DOCTYPE html>
<html>
<head>
  <title>Warehouse Simulation</title>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <style>
    body { font-family: Arial; }
    .panel { border: 1px solid #ccc; padding: 10px; margin: 10px 0; }
    .grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
    .badge { padding: 4px 8px; margin: 2px; background: #eee; display: inline-block; }
    #viz { display: flex; gap: 20px; }
  </style>
</head>

<body>

<h1>Warehouse Dashboard</h1>

<div class="panel">
  <h3>Total Inventory</h3>
  <div id="inventory"></div>
</div>

<div class="panel">
  <h3>Shelf-wise Inventory</h3>
  <div id="shelfInventory" class="grid"></div>
</div>

<div class="panel">
  <h3>Items Waiting at Supply Station</h3>
  <div id="incoming"></div>
</div>

<div class="panel">
  <h3>Delivered Items</h3>
  <div id="delivered"></div>
</div>

<div id="viz">
  <canvas id="canvas" width="500" height="500"></canvas>
  <div id="three" style="width:500px;height:500px;"></div>
</div>

<script>
const socket = io();
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const CELL = 50;

/* ============================
   2D DRAWING (UNCHANGED)
============================ */
function drawWarehouse(data){
  ctx.clearRect(0,0,500,500);
  ctx.fillStyle="#2f2f2f";
  ctx.fillRect(0,0,500,500);

  ctx.strokeStyle="#444";
  for(let i=0;i<10;i++){
    for(let j=0;j<10;j++){
      ctx.strokeRect(j*CELL, i*CELL, CELL, CELL);
    }
  }

  drawCell(0,5,"#27ae60","SS");
  drawCell(9,5,"#2980b9","DS");

  [[2,2],[2,7],[7,2],[7,7]].forEach((p,i)=>{
    drawCell(p[0],p[1],"#8d8d8d","S"+(i+1));
  });

  drawRobot(data.supply_robot,"#e74c3c","SR");
  drawRobot(data.delivery_robot,"#9b59b6","DR");
}

function drawCell(r,c,color,label){
  ctx.fillStyle=color;
  ctx.fillRect(c*CELL,r*CELL,CELL,CELL);
  ctx.fillStyle="white";
  ctx.fillText(label,c*CELL+10,r*CELL+25);
}

function drawRobot(robot,color,label){
  const [r,c]=robot.pos;
  drawCell(r,c,color,label);
}

/* ============================
   3D SETUP
============================ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(60,1,0.1,1000);
camera.position.set(6,10,12);
camera.lookAt(5,0,5);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(500,500);
document.getElementById("three").appendChild(renderer.domElement);

/* Lights */
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dir = new THREE.DirectionalLight(0xffffff,0.8);
dir.position.set(5,10,5);
scene.add(dir);

/* Floor */
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(10,10),
  new THREE.MeshStandardMaterial({color:0x444444})
);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

/* Stations */
function station(x,z,color){
  const m = new THREE.Mesh(
    new THREE.BoxGeometry(1,0.2,1),
    new THREE.MeshStandardMaterial({color})
  );
  m.position.set(x,0.1,z);
  scene.add(m);
}
station(5,0,0x27ae60);
station(5,9,0x2980b9);

/* ============================
   NEW: SHELF RACKS
============================ */
[[2,2],[2,7],[7,2],[7,7]].forEach(p=>{
  const rack = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({color:0x888888});

  // vertical posts
  const postGeo = new THREE.BoxGeometry(0.1,2,0.1);
  [[-0.45,-0.45],[0.45,-0.45],[-0.45,0.45],[0.45,0.45]].forEach(pos=>{
    const post = new THREE.Mesh(postGeo,mat);
    post.position.set(pos[0],1,pos[1]);
    rack.add(post);
  });

  // shelf levels
  const shelfGeo = new THREE.BoxGeometry(0.9,0.05,0.9);
  [0.6,1.2,1.8].forEach(y=>{
    const shelf = new THREE.Mesh(shelfGeo,mat);
    shelf.position.y=y;
    rack.add(shelf);
  });

  rack.position.set(p[1],0,p[0]);
  scene.add(rack);
});

/* ============================
   NEW: ROBOTS WITH WHEELS
============================ */
function makeRobot(color){
  const g = new THREE.Group();

  const body = new THREE.Mesh(
    new THREE.BoxGeometry(0.6,0.4,0.8),
    new THREE.MeshStandardMaterial({color})
  );
  body.position.y = 0.3;
  g.add(body);

  const wheelGeo = new THREE.CylinderGeometry(0.12,0.12,0.08,16);
  const wheelMat = new THREE.MeshStandardMaterial({color:0x111111});

  [[-0.25,-0.35],[0.25,-0.35],[-0.25,0.35],[0.25,0.35]].forEach(p=>{
    const w = new THREE.Mesh(wheelGeo,wheelMat);
    w.rotation.z = Math.PI/2;
    w.position.set(p[0],0.12,p[1]);
    g.add(w);
  });

  scene.add(g);
  return g;
}

const supplyRobot3D = makeRobot(0xe74c3c);
const deliveryRobot3D = makeRobot(0x9b59b6);

/* ============================
   SOCKET STATE (UNCHANGED)
============================ */
socket.on("state", data => {

  inventory.innerHTML = Object.entries(data.inventory)
    .map(([k,v])=><span class="badge">${k}: ${v}</span>).join("");

  let shelfHTML="";
  for(let s in data.shelf_inventory){
    shelfHTML+=<div class="panel"><b>${s}</b><br>;
    for(let i in data.shelf_inventory[s]){
      shelfHTML+=${i}: ${data.shelf_inventory[s][i]}<br>;
    }
    shelfHTML+="</div>";
  }
  shelfInventory.innerHTML=shelfHTML;

  incoming.innerHTML=data.incoming_queue.map(i=><span class="badge">${i}</span>).join("");
  delivered.innerHTML=data.delivered_items.map(i=><span class="badge">${i}</span>).join("");

  drawWarehouse(data);

  supplyRobot3D.position.set(data.supply_robot.pos[1],0,data.supply_robot.pos[0]);
  deliveryRobot3D.position.set(data.delivery_robot.pos[1],0,data.delivery_robot.pos[0]);
});

/* Render loop */
function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene,camera);
}
animate();
</script>

</body>
</html>
