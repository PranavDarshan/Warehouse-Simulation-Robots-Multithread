<!DOCTYPE html>
<html>
<head>
  <title>Warehouse Simulation</title>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      color: #e2e8f0;
      min-height: 100vh;
      padding: 2rem;
      line-height: 1.6;
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 2rem;
      letter-spacing: -0.02em;
    }

    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .panel {
      background: rgba(30, 41, 59, 0.8);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(59, 130, 246, 0.2);
      border-radius: 1rem;
      padding: 1.5rem;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .panel:hover {
      border-color: rgba(59, 130, 246, 0.5);
      box-shadow: 0 8px 16px rgba(59, 130, 246, 0.2);
      transform: translateY(-2px);
    }

    .panel h3 {
      font-size: 1.125rem;
      font-weight: 600;
      color: #f1f5f9;
      margin-bottom: 1rem;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      padding: 0.5rem 1rem;
      margin: 0.25rem;
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(139, 92, 246, 0.2));
      border: 1px solid rgba(59, 130, 246, 0.3);
      border-radius: 0.5rem;
      font-size: 0.875rem;
      font-weight: 500;
      transition: all 0.2s ease;
      color: #e2e8f0;
    }

    .badge:hover {
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(139, 92, 246, 0.3));
      transform: scale(1.05);
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }

    .shelf-card {
      background: rgba(15, 23, 42, 0.6);
      border: 1px solid rgba(100, 116, 139, 0.3);
      border-radius: 0.75rem;
      padding: 1rem;
      transition: all 0.2s ease;
    }

    .shelf-card:hover {
      border-color: rgba(100, 116, 139, 0.5);
      background: rgba(15, 23, 42, 0.8);
    }

    .shelf-card b {
      display: block;
      color: #60a5fa;
      font-size: 1rem;
      margin-bottom: 0.75rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(100, 116, 139, 0.3);
    }

    .shelf-card div {
      color: #cbd5e1;
      font-size: 0.875rem;
      padding: 0.25rem 0;
    }

    #viz {
      display: grid;
      grid-template-columns: 1fr;
      gap: 2rem;
      margin-top: 2rem;
    }

    .viz-panel {
      background: rgba(30, 41, 59, 0.8);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(59, 130, 246, 0.2);
      border-radius: 1rem;
      padding: 1.5rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .viz-panel canvas {
      width: 100%;
      height: 500px;
    }

    canvas {
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      width: 100%;
      height: auto;
    }

    #three {
      border-radius: 0.5rem;
      overflow: hidden;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      width: 100%;
      height: 700px;
    }

    #three canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    @media (max-width: 1200px) {
      #viz {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      body {
        padding: 1rem;
      }

      h1 {
        font-size: 2rem;
      }

      .dashboard-grid {
        grid-template-columns: 1fr;
      }

      #viz {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Warehouse Dashboard</h1>

    <div class="dashboard-grid">
      <div class="panel">
        <h3>Total Inventory</h3>
        <div id="inventory"></div>
      </div>

      <div class="panel">
        <h3>Items Waiting at Supply Station</h3>
        <div id="incoming"></div>
      </div>

      <div class="panel">
        <h3>Delivered Items</h3>
        <div id="delivered"></div>
      </div>
    </div>

    <div class="panel" style="margin-bottom: 2rem;">
      <h3>Shelf-wise Inventory</h3>
      <div id="shelfInventory" class="grid"></div>
    </div>

    <div id="viz">
      <div class="viz-panel">
        <h3 style="margin-bottom: 1rem;">2D Warehouse View</h3>
        <canvas id="canvas" width="500" height="500" style="max-width: 500px; margin: 0 auto; display: block;"></canvas>
      </div>
      <div class="viz-panel">
        <h3 style="margin-bottom: 1rem;">3D Warehouse View</h3>
        <div id="three" style="width:100%;height:700px;"></div>
      </div>
    </div>
  </div>

  <script>
    const socket = io();
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    // default grid and visuals; will be overridden by state if provided
    let GRID_SIZE = 10;
    let CELL = Math.floor(canvas.width / GRID_SIZE);

    const goodsColors = {A:"#fbbf24",B:"#60a5fa",C:"#34d399"};

    // fallback shelf positions (old default) will be used if server doesn't send positions
    let shelfPositions = [[2,2],[2,7],[7,2],[7,7]];

    // latest full state received from server
    let latestState = null;

    // robot animation targets & current interpolated positions (row, col)
    let supplyTarget = null;
    let deliveryTarget = null;
    let supplyAnimPos = null;
    let deliveryAnimPos = null;

    // 3D robot target vectors
    let supplyTargetVec3 = null;
    let deliveryTargetVec3 = null;

    // smoothing factor (higher -> faster)
    const robotLerp = 0.18;

    function updateGridFromState(data) {
      GRID_SIZE = data.grid_size || GRID_SIZE || 10;
      CELL = Math.floor(canvas.width / GRID_SIZE);
      // parse shelf_positions if provided in many forms (array or object)
      if (data.shelf_positions) {
        const sp = data.shelf_positions;
        if (Array.isArray(sp)) {
          shelfPositions = sp.map(p => Array.isArray(p) ? p.slice(0,2) : [p[0], p[1]]);
        } else {
          // object form: {0:[r,c], 1:[r,c], ...}
          shelfPositions = Object.keys(sp).sort((a,b)=>Number(a)-Number(b)).map(k => {
            const v = sp[k];
            return Array.isArray(v) ? v.slice(0,2) : [v[0], v[1]];
          });
        }
      } else {
        // if no shelf positions sent but shelves length differs from fallback, spread shelves in a grid line
        if (data.shelves && data.shelves.length !== shelfPositions.length) {
          const n = data.shelves.length;
          shelfPositions = [];
          // simple auto-layout: place shelves along middle rows
          const mid = Math.floor(GRID_SIZE/2);
          for (let i=0;i<n;i++){
            const col = Math.max(0, Math.floor((i+1) * (GRID_SIZE-2) / (n+1)));
            shelfPositions.push([mid, col+1]);
          }
        }
      }
    }

    function emitStateDrawHelpers(data){
      // used by drawWarehouse and 3D code
      updateGridFromState(data);
    }

    function drawBox(x, y, itemType) {
      const color = goodsColors[itemType] || "#e2e8f0";
      // increased visual size so boxes are clearly visible in shelves
      const boxSize = Math.max(14, Math.min(40, CELL * 0.55));
      const boxX = x * CELL + CELL/2 - boxSize/2;
      const boxY = y * CELL + CELL/2 - boxSize/2;

      ctx.shadowColor = "rgba(0,0,0,0.4)";
      ctx.shadowBlur = 6;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;

      ctx.fillStyle = color;
      ctx.fillRect(boxX, boxY, boxSize, boxSize);

      ctx.shadowColor = "transparent";
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = Math.max(2, Math.floor(boxSize * 0.08));
      ctx.strokeRect(boxX, boxY, boxSize, boxSize);

      ctx.fillStyle = "#000000";
      ctx.font = `bold ${Math.max(12, Math.floor(boxSize*0.6))}px Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(itemType, x * CELL + CELL/2, y * CELL + CELL/2);
    }

    function drawWarehouse(data){
      // data may be null during initialization
      data = data || {};

      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle="#0f172a";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // draw grid
      ctx.strokeStyle="#334155";
      for(let i=0;i<GRID_SIZE;i++){
        for(let j=0;j<GRID_SIZE;j++){
          ctx.strokeRect(j*CELL, i*CELL, CELL, CELL);
        }
      }

      // draw supply/delivery stations (prefer explicit station positions if provided)
      const ssPos = data.supply_station || (data.supply_robot && data.supply_robot.pos) || [0, Math.floor(GRID_SIZE/2)];
      const dsPos = data.delivery_station || (data.delivery_robot && data.delivery_robot.pos) || [GRID_SIZE-1, Math.floor(GRID_SIZE/2)];
      // draw colored station cells (orange for supply, purple for delivery)
      drawCell(ssPos[0], ssPos[1], "#f97316", "SS");
      drawCell(dsPos[0], dsPos[1], "#8b5cf6", "DS");

      // draw shelves using dynamic shelfPositions
      shelfPositions.forEach((p,i)=>{
        drawCell(p[0], p[1], "#64748b", "S"+(i+1));
      });

      if(data.shelves) {
        data.shelves.forEach((shelf, shelfIdx) => {
          const pos = shelfPositions[shelfIdx] || [0,0];
          const [shelfRow, shelfCol] = pos;
          shelf.forEach((item, slotIdx) => {
            if(item) {
              const offsetX = (slotIdx % 3 - 1) * 0.25;
              const offsetY = Math.floor(slotIdx / 3) * 0.35 - 0.2;
              drawBox(shelfCol + offsetX, shelfRow + offsetY, item);
            }
          });
        });
      }

      // draw robots using interpolated positions (smoother)
      if(supplyAnimPos) {
        drawRobotPos(supplyAnimPos, "#ef4444", "SR");
        // carried box near robot
        if(data.supply_robot && data.supply_robot.carrying) {
          drawBox(supplyAnimPos[1] - 0.3, supplyAnimPos[0] - 0.3, data.supply_robot.carrying);
        }
      } else if(data.supply_robot) {
        drawRobot(data.supply_robot,"#ef4444","SR");
      }

      if(deliveryAnimPos) {
        drawRobotPos(deliveryAnimPos, "#8b5cf6", "DR");
        if(data.delivery_robot && data.delivery_robot.carrying) {
          drawBox(deliveryAnimPos[1] - 0.3, deliveryAnimPos[0] - 0.3, data.delivery_robot.carrying);
        }
      } else if(data.delivery_robot) {
        drawRobot(data.delivery_robot,"#8b5cf6","DR");
      }
    }

    // draw using float pos [row,col]
    function drawRobotPos(pos, color, label){
      const [r,c] = pos;
      drawCell(r,c,color,label);
    }

    function drawCell(r,c,color,label){
      ctx.fillStyle=color;
      ctx.fillRect(c*CELL,r*CELL,CELL,CELL);
      ctx.fillStyle="white";
      ctx.font="bold 14px Arial";
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.fillText(label,c*CELL+CELL/2,r*CELL+CELL/2);
    }

    function drawRobot(robot,color,label){
      const [r,c]=robot.pos;
      drawCell(r,c,color,label);
    }

    // ---------- 3D Setup ----------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0f172a);

    const threeContainer = document.getElementById("three");
    let camera = new THREE.PerspectiveCamera(60,threeContainer.clientWidth/700,0.1,1000);
    // same angle, moved back a little on Z so delivery station is more visible
    camera.position.set(4,6,9);
    camera.lookAt(0,0,0);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(threeContainer.clientWidth,700);
    threeContainer.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff,0.6));
    const dir = new THREE.DirectionalLight(0xffffff,0.8);
    dir.position.set(5,10,5);
    scene.add(dir);

    let floor = new THREE.Mesh(
      new THREE.PlaneGeometry(GRID_SIZE,GRID_SIZE),
      new THREE.MeshStandardMaterial({color:0x1e293b})
    );
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    let gridHelper = new THREE.GridHelper(GRID_SIZE,GRID_SIZE,0x475569,0x334155);
    scene.add(gridHelper);

    function to3D(x,z){
      return [x - GRID_SIZE/2 + 0.5, 0, z - GRID_SIZE/2 + 0.5];
    }

    // dynamic arrays to manage meshes
    let shelfRacks3D = [];
    let shelfBoxes3D = [];
    let stationMeshes = [];
    let supplyRobot3D = null;
    let deliveryRobot3D = null;
    let supplyRobotBox3D = null;
    let deliveryRobotBox3D = null;

    const goodsColors3D = {A:0xfbbf24,B:0x60a5fa,C:0x34d399};

    function disposeGroup(g){
      if(!g) return;
      g.traverse(obj => {
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)){
            obj.material.forEach(m => { if(m.map) m.map.dispose(); m.dispose(); });
          } else {
            if(obj.material.map) obj.material.map.dispose();
            obj.material.dispose();
          }
        }
      });
    }

    function clearArrayOfMeshes(arr){
      arr.forEach(m=>{
        scene.remove(m);
        disposeGroup(m);
      });
      arr.length = 0;
    }

    function buildRacks(positions){
      clearArrayOfMeshes(shelfRacks3D);
      positions.forEach(p=>{
        const [r,c] = p;
        const rack = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({color:0x64748b});

        const postGeo = new THREE.BoxGeometry(0.1,2,0.1);
        [[-0.45,-0.45],[0.45,-0.45],[-0.45,0.45],[0.45,0.45]].forEach(pos=>{
          const post = new THREE.Mesh(postGeo,mat);
          post.position.set(pos[0],1,pos[1]);
          rack.add(post);
        });

        const shelfGeo = new THREE.BoxGeometry(0.9,0.05,0.9);
        [0.6,1.2,1.8].forEach(y=>{
          const shelf = new THREE.Mesh(shelfGeo,mat);
          shelf.position.y=y;
          rack.add(shelf);
        });

        const [x3, y3, z3] = to3D(c, r);
        rack.position.set(x3, y3, z3);
        scene.add(rack);
        shelfRacks3D.push(rack);
      });
    }

    function clearShelfBoxes() {
      clearArrayOfMeshes(shelfBoxes3D);
    }

    function clearRobotBox(robotBox) {
      if(robotBox) {
        scene.remove(robotBox);
        disposeGroup(robotBox);
      }
      return null;
    }

    function makeRobot(color){
      const g = new THREE.Group();

      const body = new THREE.Mesh(
        new THREE.BoxGeometry(0.5,0.35,0.7),
        new THREE.MeshStandardMaterial({color,metalness:0.3,roughness:0.7})
      );
      body.position.y = 0.25;
      g.add(body);

      const top = new THREE.Mesh(
        new THREE.BoxGeometry(0.45,0.15,0.6),
        new THREE.MeshStandardMaterial({color:color,metalness:0.2,roughness:0.8})
      );
      top.position.y = 0.48;
      g.add(top);

      const bumper = new THREE.Mesh(
        new THREE.BoxGeometry(0.05,0.2,0.75),
        new THREE.MeshStandardMaterial({color:0x94a3b8,metalness:0.4,roughness:0.6})
      );
      bumper.position.set(0.28,0.2,0);
      g.add(bumper);

      const wheelGeo = new THREE.CylinderGeometry(0.14,0.14,0.1,16);
      const wheelMat = new THREE.MeshStandardMaterial({color:0x0f172a,metalness:0.8,roughness:0.4});

      [[-0.2,-0.3],[0.2,-0.3],[-0.2,0.3],[0.2,0.3]].forEach(p=>{
        const w = new THREE.Mesh(wheelGeo,wheelMat);
        w.rotation.z = Math.PI/2;
        w.position.set(p[0],0.12,p[1]);
        g.add(w);
      });

      scene.add(g);
      return g;
    }

    // create robots up front (they will be repositioned on first state)
    supplyRobot3D = makeRobot(0xef4444);
    deliveryRobot3D = makeRobot(0x8b5cf6);

    function createBox3D(type){
      const group = new THREE.Group();
      const color = goodsColors3D[type]||0xe2e8f0;

      // larger box for better visibility
      const size = 0.28;
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(size, size, size),
        new THREE.MeshStandardMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.12,
          metalness: 0.25,
          roughness: 0.6
        })
      );
      group.add(box);

      // higher-resolution label canvas so text is crisp on bigger boxes
      const canvasLabel = document.createElement('canvas');
      canvasLabel.width = 256;
      canvasLabel.height = 256;
      const context = canvasLabel.getContext('2d');
      context.clearRect(0,0,256,256);
      context.fillStyle = 'rgba(255,255,255,0.0)';
      context.fillRect(0,0,256,256);
      context.fillStyle = '#000000';
      context.font = 'bold 180px Arial';
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillText(type, 128, 128);

      const texture = new THREE.CanvasTexture(canvasLabel);
      texture.needsUpdate = true;
      const labelMat = new THREE.MeshBasicMaterial({map: texture, transparent: true});

      // scale label planes to match larger box size
      const faceSize = 0.22;
      [
        [0, 0, size/2 + 0.01, 0, 0, 0],
        [0, 0, -size/2 - 0.01, 0, Math.PI, 0],
        [size/2 + 0.01, 0, 0, 0, Math.PI/2, 0],
        [-size/2 - 0.01, 0, 0, 0, -Math.PI/2, 0],
      ].forEach(([px, py, pz, rx, ry, rz]) => {
        const label = new THREE.Mesh(
          new THREE.PlaneGeometry(faceSize, faceSize),
          labelMat
        );
        label.position.set(px, py, pz);
        label.rotation.set(rx, ry, rz);
        group.add(label);
      });

      scene.add(group);
      return group;
    }

    // ---------- animation loop ----------
    function animate(){
      requestAnimationFrame(animate);

      // interpolate 2D robot positions toward targets
      if (latestState) {
        if (supplyTarget) {
          if (!supplyAnimPos) supplyAnimPos = [supplyTarget[0], supplyTarget[1]];
          supplyAnimPos[0] += (supplyTarget[0] - supplyAnimPos[0]) * robotLerp;
          supplyAnimPos[1] += (supplyTarget[1] - supplyAnimPos[1]) * robotLerp;
        }
        if (deliveryTarget) {
          if (!deliveryAnimPos) deliveryAnimPos = [deliveryTarget[0], deliveryTarget[1]];
          deliveryAnimPos[0] += (deliveryTarget[0] - deliveryAnimPos[0]) * robotLerp;
          deliveryAnimPos[1] += (deliveryTarget[1] - deliveryAnimPos[1]) * robotLerp;
        }

        // interpolate 3D robot positions toward targets
        if (supplyTargetVec3) {
          supplyRobot3D.position.lerp(supplyTargetVec3, robotLerp);
          if (supplyRobotBox3D) {
            supplyRobotBox3D.position.lerp(new THREE.Vector3(supplyRobot3D.position.x - 0.25, 0.65, supplyRobot3D.position.z), robotLerp);
          }
        }
        if (deliveryTargetVec3) {
          deliveryRobot3D.position.lerp(deliveryTargetVec3, robotLerp);
          if (deliveryRobotBox3D) {
            deliveryRobotBox3D.position.lerp(new THREE.Vector3(deliveryRobot3D.position.x - 0.25, 0.65, deliveryRobot3D.position.z), robotLerp);
          }
        }

        // draw 2D every frame with interpolated robot positions
        drawWarehouse(latestState);
      }

      renderer.render(scene,camera);
    }
    animate();

    // ---------- Socket state handling ----------
    socket.on("state", data => {
      // store full state for continuous drawing
      latestState = data;

      // update UI panels
      inventory.innerHTML = Object.entries(data.inventory || {})
        .map(([k,v])=>`<span class="badge">${k}: ${v}</span>`).join("");

      let shelfHTML="";
      for(let s in data.shelf_inventory || {}){
        shelfHTML+=`<div class="shelf-card"><b>${s}</b><br>`;
        for(let i in data.shelf_inventory[s]){
          shelfHTML+=`<div>${i}: ${data.shelf_inventory[s][i]}</div>`;
        }
        shelfHTML+="</div>";
      }
      shelfInventory.innerHTML=shelfHTML;

      incoming.innerHTML=(data.incoming_queue||[]).map(i=>`<span class="badge">${i}</span>`).join("");
      delivered.innerHTML=(data.delivered_items||[]).map(i=>`<span class="badge">${i}</span>`).join("");

      // update helper data (grid size, shelf positions, etc)
      emitStateDrawHelpers(data);

      // update 3D floor & grid to match grid size if changed
      if(floor){
        scene.remove(floor);
        disposeGroup(floor);
      }
      floor = new THREE.Mesh(new THREE.PlaneGeometry(GRID_SIZE,GRID_SIZE), new THREE.MeshStandardMaterial({color:0x1e293b}));
      floor.rotation.x = -Math.PI/2;
      scene.add(floor);

      if(gridHelper){
        scene.remove(gridHelper);
      }
      gridHelper = new THREE.GridHelper(GRID_SIZE, GRID_SIZE, 0x475569, 0x334155);
      scene.add(gridHelper);

      // rebuild racks based on dynamic shelfPositions
      buildRacks(shelfPositions);

      clearShelfBoxes();

      // place shelf boxes in 3D
      if(data.shelves) {
        data.shelves.forEach((shelf, shelfIdx) => {
          const pos = shelfPositions[shelfIdx] || [0,0];
          const [shelfRow, shelfCol] = pos;
          const [baseX, baseY, baseZ] = to3D(shelfCol, shelfRow);

          shelf.forEach((item, slotIdx) => {
            if(item) {
              const box = createBox3D(item);

              const offsetX = ((slotIdx % 3) - 1) * 0.2;
              const offsetZ = (Math.floor(slotIdx / 3) - 0.5) * 0.2;
              // place box on top of shelf surface (not centered inside it)
              const shelfHeights = [0.6, 1.2, 1.8]; // same heights used when building racks
              const shelfThickness = 0.05;
              const shelfLevel = Math.floor(slotIdx / 3);
              const shelfY = shelfHeights[shelfLevel] !== undefined ? shelfHeights[shelfLevel] : shelfHeights[shelfHeights.length - 1];

              // match createBox3D size (must match the size used there)
              const boxHeight = 0.28;
              // top of shelf = shelfY + (shelfThickness / 2)
              // box center should be at shelfTop + boxHeight/2
              const heightY = shelfY + (shelfThickness / 2) + (boxHeight / 2);

              box.position.set(baseX + offsetX, heightY, baseZ + offsetZ);
              shelfBoxes3D.push(box);
            }
          });
        });
      }

      // set animation targets for robots (2D)
      if (data.supply_robot && Array.isArray(data.supply_robot.pos)) {
        supplyTarget = [data.supply_robot.pos[0], data.supply_robot.pos[1]];
      } else if (data.supply_station) {
        supplyTarget = [data.supply_station[0], data.supply_station[1]];
      }

      if (data.delivery_robot && Array.isArray(data.delivery_robot.pos)) {
        deliveryTarget = [data.delivery_robot.pos[0], data.delivery_robot.pos[1]];
      } else if (data.delivery_station) {
        deliveryTarget = [data.delivery_station[0], data.delivery_station[1]];
      }

      // set animation targets for robots (3D) using to3D helper
      if (data.supply_robot && Array.isArray(data.supply_robot.pos)) {
        const [sx, sy, sz] = to3D(data.supply_robot.pos[1], data.supply_robot.pos[0]);
        supplyTargetVec3 = new THREE.Vector3(sx, sy, sz);
      } else if (data.supply_station) {
        const [sx, sy, sz] = to3D(data.supply_station[1], data.supply_station[0]);
        supplyTargetVec3 = new THREE.Vector3(sx, sy, sz);
      }

      if (data.delivery_robot && Array.isArray(data.delivery_robot.pos)) {
        const [dx, dy, dz] = to3D(data.delivery_robot.pos[1], data.delivery_robot.pos[0]);
        deliveryTargetVec3 = new THREE.Vector3(dx, dy, dz);
      } else if (data.delivery_station) {
        const [dx, dy, dz] = to3D(data.delivery_station[1], data.delivery_station[0]);
        deliveryTargetVec3 = new THREE.Vector3(dx, dy, dz);
      }

      // ensure robot box meshes exist / removed, but do not teleport - their positions will be interpolated in animate()
      if(data.supply_robot) {
        if(data.supply_robot.carrying) {
          if(!supplyRobotBox3D || supplyRobotBox3D.userData.itemType !== data.supply_robot.carrying) {
            supplyRobotBox3D = clearRobotBox(supplyRobotBox3D);
            supplyRobotBox3D = createBox3D(data.supply_robot.carrying);
            supplyRobotBox3D.userData.itemType = data.supply_robot.carrying;
          }
        } else {
          supplyRobotBox3D = clearRobotBox(supplyRobotBox3D);
        }
      }

      if(data.delivery_robot) {
        if(data.delivery_robot.carrying) {
          if(!deliveryRobotBox3D || deliveryRobotBox3D.userData.itemType !== data.delivery_robot.carrying) {
            deliveryRobotBox3D = clearRobotBox(deliveryRobotBox3D);
            deliveryRobotBox3D = createBox3D(data.delivery_robot.carrying);
            deliveryRobotBox3D.userData.itemType = data.delivery_robot.carrying;
          }
        } else {
          deliveryRobotBox3D = clearRobotBox(deliveryRobotBox3D);
        }
      }

      // create station markers using explicit station positions if available
      clearArrayOfMeshes(stationMeshes);
      const ss = data.supply_station || (data.supply_robot ? data.supply_robot.pos : [0, Math.floor(GRID_SIZE/2)]);
      const ds = data.delivery_station || (data.delivery_robot ? data.delivery_robot.pos : [GRID_SIZE-1, Math.floor(GRID_SIZE/2)]);
      // station helper
      function addStation(p,color){
        const m = new THREE.Mesh(new THREE.BoxGeometry(1,0.2,1), new THREE.MeshStandardMaterial({color}));
        const [px,py,pz] = to3D(p[1], p[0]);
        m.position.set(px,0.1,pz);
        scene.add(m);
        stationMeshes.push(m);
      }
      addStation(ss,0xf97316); // orange
      addStation(ds,0x8b5cf6); // purple
    });
  </script>
</body>
</html>
